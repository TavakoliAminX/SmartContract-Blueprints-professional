// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

/**
 * @title Basic Data Interaction (Set and Get)
 * @dev Demonstrates how to initialize variables using a constructor and perform 
 * simple Create, Read, and Delete (CRUD) operations on mappings.
 */

contract SetContract {
    address public owner;
    // Mapping: Stores a string value associated with a user's address.
    mapping (address => string ) public userLists;

    // Constructor: Sets the initial contract owner upon deployment.
    constructor(address _owner){
        owner  = _owner; 
    }

    // Function to set (or update) a string value for a specific address.
    function setList(address _user, string memory _name) public {
        userLists[_user] = _name;
    }

    // Function to get (read) the string value associated with an address.
    function getList(address _user) public view returns(string memory){
        return userLists[_user];
    }
}


contract GetContract {
    // Mapping: Stores user data.
    mapping (address => string ) public userEntryList;

    // Function to set or update a string value.
    function setEntry(address _user, string memory _name) public {
        userEntryList[_user] = _name;
    }

    // Function to get a string value.
    function getEntry(address _user) public view returns(string memory){
        return userEntryList[_user];
    }

    // Function to delete (reset to empty) the value associated with an address.
    function deleteEntry(address _user) public {
        delete userEntryList [_user];
    }
}
// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

/**
 * @title Struct and Mapping Demonstration
 * @dev Shows how to define custom data types (Structs) and map them to unique IDs 
 * for inventory or registry tracking.
 */
contract ItemManager { // Renamed from Struct
    // Struct: A custom data type to group related variables for a single item.
    struct Item{
        string name;
        uint price; 
        address seller;
    }
    
    // Counter for assigning unique IDs to new items.
    uint public idCount; 
    
    // Mapping: Stores Item structs, accessible by a unique uint ID.
    mapping (uint => Item) public Items;

    // Function to add a new item to the inventory.
    function addItem(string memory _name , uint _price , address _seller) public { // Renamed from Add
        // 1. Create a new Item struct and assign it to the current ID.
        Items[idCount] = Item({
            name : _name,
            price : _price,
            seller: _seller
        });
        // 2. Increment the counter for the next item's ID.
        idCount++;
    }
}

contract AddressBook { // Renamed from Struct2
    // Struct: Renamed from 'Add' to 'Entry' for clarity.
    struct Entry{
        string name;
        uint price;
        address seller; 
    }
    // Mapping: Stores Entry structs, accessible by a unique uint ID.
    mapping (uint => Entry) public entries; // Renamed from 'adds'

    // Function to add a new entry using a specified ID.
    function addEntry(string memory _name , uint _price , address _seller , uint ID) public { // Renamed from 'addTo'
        entries[ID] = Entry({ 
            name : _name,
            price : _price,
            seller : _seller
        });
    }
}
// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

/**
 * @title Dynamic Array and Loop Demonstration
 * @dev Shows how to initialize a dynamic array and calculate its sum using a for-loop.
 */
contract ArrayLoop{ // Renamed from Loop
    // Dynamic array to store numbers.
    uint[] public numbers; 

    // Constructor: Initializes the array with values passed during deployment.
    constructor(uint [] memory _numbers){ // Renamed _number to _numbers
        numbers = _numbers; 
    }

    // Function to calculate the sum of all elements in the 'numbers' array.
    function sumArray() public view returns(uint) { // Renamed from loopFor
        uint sum = 0;
        
        // Loop: Iterates through the array indices.
        for(uint i; i < numbers.length; i++){
            // Corrected: Sums the array value at the current index (numbers[i]).
            sum += numbers[i]; 
        } 
        return sum;
    }
}
